name: Soak Test (CI)

on:
  pull_request:
    branches: [main, develop]
    paths:
      - 'src/**'
      - 'Cargo.toml'
      - 'Cargo.lock'

  # Allow manual trigger
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always

jobs:
  quick-soak-test:
    name: Quick Soak Test (10m)
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-action@stable

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2

      - name: Build Sockudo (release)
        run: cargo build --release

      - name: Build Sender (release)
        run: cargo build --release --manifest-path benchmarks/sender/Cargo.toml

      - name: Install k6
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: Create test config
        run: |
          mkdir -p config
          cat > config/ci-soak-test.json << 'EOF'
          {
            "debug": false,
            "port": 6001,
            "metrics": {
              "enabled": true,
              "port": 9601
            },
            "app_manager": {
              "driver": "memory",
              "memory": {
                "apps": [
                  {
                    "id": "ci-app",
                    "key": "app-key",
                    "secret": "app-secret",
                    "max_connections": 1000,
                    "enable_client_messages": true
                  }
                ]
              }
            },
            "rate_limiter": {
              "enabled": false
            }
          }
          EOF

      - name: Start Sockudo
        run: |
          ./target/release/sockudo --config config/ci-soak-test.json &
          echo $! > sockudo.pid
          sleep 3
          curl -f http://localhost:6001/up/ci-app
          curl -f http://localhost:9601/metrics | grep process_resident_memory_bytes
          echo "Sockudo ready"

      - name: Start message sender
        run: |
          ./benchmarks/sender/target/release/sender \
            --host 127.0.0.1 \
            --port 6001 \
            --app-id ci-app \
            --app-key app-key \
            --app-secret app-secret \
            --channel price:* \
            --interval 0.01 &
          echo $! > sender.pid
          sleep 2

      - name: Run quick soak test
        id: soak
        run: |
          VUS=100 \
          SOAK_DURATION=10m \
          RAMP_UP=1m \
          RAMP_DOWN=1m \
          APP_KEY=app-key \
          APP_ID=ci-app \
          METRICS_URL=http://localhost:9601/metrics \
          THRESHOLD_MEMORY_GROWTH_MB=200 \
          THRESHOLD_WS_ERRORS=500 \
          k6 run benchmarks/k6-soak-test.js \
            --summary-export=soak-results.json \
            2>&1 | tee soak-output.log

          # Extract results
          GROWTH=$(jq -r '.summary.server_memory.growth_mb // "0"' soak-results.json)
          LEAK=$(jq -r '.summary.server_memory.leak_detected // false' soak-results.json)
          echo "memory_growth=$GROWTH" >> $GITHUB_OUTPUT
          echo "leak_detected=$LEAK" >> $GITHUB_OUTPUT

      - name: Stop services
        if: always()
        run: |
          kill $(cat sender.pid) 2>/dev/null || true
          kill $(cat sockudo.pid) 2>/dev/null || true

      - name: Upload results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: soak-test-ci-${{ github.run_id }}
          path: |
            soak-results.json
            soak-output.log
          retention-days: 7

      - name: Summary
        if: always()
        run: |
          echo "## Quick Soak Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f soak-results.json ]; then
            GROWTH=$(jq -r '.summary.server_memory.growth_mb // "N/A"' soak-results.json)
            FIRST=$(jq -r '.summary.server_memory.first_sample_mb // "N/A"' soak-results.json)
            LAST=$(jq -r '.summary.server_memory.last_sample_mb // "N/A"' soak-results.json)
            LEAK=$(jq -r '.summary.server_memory.leak_detected // false' soak-results.json)
            CONNS=$(jq -r '.summary.connection_metrics.total_connections // "N/A"' soak-results.json)
            MSGS=$(jq -r '.summary.message_metrics.total_received // "N/A"' soak-results.json)
            ERRORS=$(jq -r '.summary.error_metrics.ws_errors // "N/A"' soak-results.json)

            if [ "$LEAK" == "true" ]; then
              echo "### ❌ Memory Leak Detected" >> $GITHUB_STEP_SUMMARY
            else
              echo "### ✅ No Memory Leak" >> $GITHUB_STEP_SUMMARY
            fi

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Memory Start | $FIRST MB |" >> $GITHUB_STEP_SUMMARY
            echo "| Memory End | $LAST MB |" >> $GITHUB_STEP_SUMMARY
            echo "| **Memory Growth** | **$GROWTH MB** |" >> $GITHUB_STEP_SUMMARY
            echo "| Connections | $CONNS |" >> $GITHUB_STEP_SUMMARY
            echo "| Messages | $MSGS |" >> $GITHUB_STEP_SUMMARY
            echo "| Errors | $ERRORS |" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Results not available" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Fail on leak
        if: steps.soak.outputs.leak_detected == 'true'
        run: |
          echo "::error::Memory leak detected! Growth: ${{ steps.soak.outputs.memory_growth }} MB"
          exit 1
